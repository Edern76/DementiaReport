<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><title>Découpage du projet</title>

<style type="text/css">
#content {
display: table;
}
#pageFooter {
display: table-footer-group;
}
#pageFooter:after {
counter-increment: page; content:"Page " counter(page);
left: 0; top: 100%;
white-space: nowrap; z-index: 20px;
-moz-border-radius: 5px; -moz-box-shadow: 0px 0px 4px #222; background-image: -moz-linear-gradient(top, #eeeeee, #cccccc); background-image: -moz-linear-gradient(top, #eeeeee, #cccccc); }
div.code {
border-style: solid;
border-width: 1px;
font-family: "Courier New",Courier,monospace;
background-color: #cccccc;
}
IMG.displayed {
display: block;
margin-left: auto;
margin-right: auto;
}
.pagebreak { page-break-before: always; }
</style>
<script type="text/javascript">
function codeAddress() {
alert('La CSS de ma page HTML semble causer des problèmes qui font que la page est tronquée. \n Pour remédier à cela, la barre de menu a été supprimée. \n Si vous la voulez de retour, cliquez sur Page d accueil');
var element = document.getElementById("sidemenu");
element.outerHTML = "";
delete element;
var ban = document.getElementById("banner");
ban.outerHTML = "";
delete ban
}
window.onload = codeAddress;
</script></head>
<body>
<h1 style="text-align: center; text-decoration: underline;">Le
Projet du Bac</h1>
<h2 style="text-decoration: underline;">Consignes à
respecter :</h2>
<p><br>
Utilisez dans cette partie de votre travail un chapitre pour chaque
éléments de construction du projet final.<br>
Utilisez des titres de chapitres en rapport avec les domaines évalués à
l'oral.<br>
N'hésitez pas à détailler la progression du travail et faites référence
à ce qui est traité par le (les) autre(s) membre(s) du groupe.</p>
<p>Le découpage ci-dessous en 2 parties à chaque fois n'a rien
d'un caractère obligatoire .... mais il fallait bien commencer par un
modèle.<br>
&nbsp;</p>
<h2 style="text-decoration: underline;">Le projet : titre,
description et contenu du cahier des charges.</h2>
<h3><br>
</h3>
Notre projet, intitulé <span style="font-style: italic;">Dementia
RL</span>, est un jeu vidéo de type <span style="font-style: italic;">roguelike</span> développé
en langage Python 3 et sous license BSD 2-Clause. Nous avons choisi de
travailler sur un tel projet car, sans être d'une difficulté
insurmontable, cela nous a permi de mettre au défi nos compétences en
matière de programmation, et d'apprendre de nouveaux concepts et de
nouvelles techniques de programmation afin de surmonter certains
obstacles. De plus, appréciant tous deux jouer aux jeux-vidéos, l'idée
d'en créer un nous même nous est venue assez naturellement.
<h3><br style="text-decoration: underline;">
&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 1&nbsp; :
Définition d'un roguelike</span><br>
&nbsp;</h3>
Un <span style="font-style: italic;">roguelike</span>
est un type de jeu vidéo proche du RPG (jeu de rôles). Dans un jeu de
rôles, on incarne un personnage que l'on a crée au préalable, que l'on
doit guider dans un (ou plusieurs) donjons&nbsp;afin d'atteindre un
but final, qui varie selon les jeux mais constitue souvent à récupérer
un objet clé ou à tuer un antagoniste particulièrement puissant, aussi
appelé <span style="font-style: italic;">boss final</span>.
Au cours de ces aventures, ce personnage rencontre des monstres qu'il
va devoir tuer (ou éviter) à l'aide de plusieurs moyens mis à sa
disposition : que ce soit à l'aide d'armes à distance, d'armes de mêlée
ou de magie. Tuer des monstres rapporte des points d'expérience, qui
lorsque ils sont amassés en quantité suffisante permettent au joueur de
gagner des niveaux, qui lui permettent de monter en puissance. Il peut
également ramasser des objets aux divers effets qu'il peut stocker dans
son inventaire pour les utiliser plus tard, ainsi que de l'équipement
dont il peut s'équiper pour augmenter ses caractéristiques. Un
roguelike reprend ces codes, et y rajoute le concept de <span style="font-style: italic;">permadeath</span> (mort
permanente : lorsque le personnage du joueur meurt, il doit recommencer
le jeu à partir de zéro), le fait que les différents étages du donjon
soient générés aléatoirement à chaque partie, et le fait que le joueur
doive gérer ses ressources (faim, points de vie, points d'énergie...)
attentivement car les objets sont en quantité limitée. De plus, un
roguelike se joue forcément au tour par tour (le jeu n'avance que après
que le joueur aie effectué une action, si cette condition n'est pas
satisfaite il ne s'agit pas d'un <span style="font-style: italic;">roguelike</span>
mais d'un <span style="font-style: italic;">roguelite</span>),
et ses graphismes sont souvent des graphismes en ASCII (un caractère
représente un monstre, un objet, etc...). Nous avons choisi de
développer un tel jeu pour plusieurs raisons :
<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - Tout
d'abord, le fait que les graphismes soient
traditionellement des graphismes en ASCII nous permet de passer un
temps quasi inexistant sur la création des graphismes (puisque ceux-ci
se résument à un simple caractère), et donc de nous concentrer sur la
partie programmation.
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
-&nbsp;Ensuite, car il n'existe pas beaucoup de roguelikes écrits
en Python, et encore moins en Python 3.
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - Enfin,
car nous avons trouvé que la combinaison du système
de mort permanente avec la génération aléatioire permet une durée de
vie quasi infinie : chaque partie est unique, et le joueur est forcé de
constamment réfléchir à ses choix, car le moindre faux pas peut se
traduire par le fait d'avoir à repartir de 0.
<br>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 2&nbsp; :
Description de notre projet</span><br>
&nbsp;</h3>
<span style="font-style: italic;">Note : Cette partie sera
mise à jour lorsque les fonctionnalités évoquées comme étant en cours
de développement seront implémentées. Pour plus de détails, merci de
vous réferer aux <a href="https://lea.hautenormandie.fr/group/spe_isn_2016_1017/atelier/-/wiki/Main/Deadlines+du+projet/maximized">deadlines</a>.<br>
</span>
<p>Notre roguelike comporte actuellement un système de gestion de
faim, de l'inventaire et de l'équipement (avec gestion du poids), un
système de sauvegarde et de chargement, quelques sorts, objets et
ennemis basiques, quelques types différents d'intelligences
artificielle, ainsi qu'un donjon principal qui comporte une 'branche'
secondaire se terminant par un <span style="font-style: italic;">boss</span>.
Nous prévoyons d'ajouter dans un futur proche des personnages non
jouables avec lequel le joueur peut dialoguer, plus de monstres,
objets, sorts, et 'branches' secondaires, un système de 'meilleurs
scores', un système de persistence entre les parties (vous pourrez
croiser le monstre qui vous a tué lors d'une partie précédente, et a
par conséquent gagné en puissance et éventuellement récupéré quelques
uns des objets de votre personnage précédent que vous pouvez récupérer
en tuant le dit monstre) ainsi qu'un tutoriel, expliquant les bases du
jeu et permettant d'établir le scénario.</p>
<p>Pour ce qui est du scénario, &nbsp;votre personnage a
tenté de vaincre Zargothrox, un magicien maléfique et immensément
puissant qui menaçait de détruire votre monde. Néanmoins, celui-ci
s'est révélé être trop puissant pour vous ; il vous a piégé et vous a
téléporté dans le donjon dans lequel vous vous trouvez, rempli de
monstres sanguinaires et autres horreurs indescriptibles. Pire encore :
à chaque mort, vous revenez à la vie sous une forme différente, et la
forme et la structure du donjon change complètement. Vous êtes donc
condamner à errer pour l'éternité dans les couloirs de cet endroit
abominable, à moins que vous ne trouviez un moyen de vous échapper, et
d'accessoirement prendre votre revanche sur Zargothrox, qui constituera
le boss final.</p>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 3&nbsp; :
Modules requis :</span></h3>
Notre programme utilise principalement une version modifiée du module <span style="font-weight: bold;">TDL</span> (basée sur la
version 1.5.3, notre projet ne fonctionne pas sous les versions plus
récentes) écrit par Kyle Stewart, disponible sous license BSD 2-Clause,
et inclus dans les fichiers du projet, dans le
dossier tdlib (car nous avons eu besoin d'en modifier certains
fichiers). Ce module permet de créer une console divisée en une grille
(chaque case est donc associée à un couple de coordonnées (x,y)), et
d'afficher des caractères ASCII de différentes couleurs à des
coordonées (x,y) de la console précise. On peut également diviser la
console en plusieurs parties, chacune ayant alors son propre système de
coordonnées, et afficher directement des chaînes de caractères (plutôt
que d'avoir à afficher individuellement chaque caractère). Il s'agit
également du module gérant les entrées clavier, qu'il retourne sous la
forme d'une chaîne de caractère associée au nom de la touche, on peut
alors utiliser cette chaîne dans nos propres fonctions afin d'effectuer
diverses actions selon la touche enfoncée.<br>
<br>
<br>
Nous utilisons également une version modifiée par nos soins pour être
compatible avec Python 3 (et TDL) du module <span style="font-weight: bold;">XpLoader</span>, écrit par
Sean Hagar en Python 2 (et sous license MIT) afin de pouvoir afficher
les images produites avec <span style="font-weight: bold;">REXPaint</span>
(un logiciel gratuit permettant de produire des images constituées
uniquement de caractères ASCII - soit de l'ASCII art - et faisant
figure de référence dans la communauté des développeurs de roguelike)
directement dans une console libtcod (l'"ancêtre" en Python 2 de TDL).
<br>
En effet, REXPaint produit des fichiers .xp (ou .png, mais TDL ne
permet d'afficher que de l'ASCII, on ne peut donc pas afficher d'images
au format traditionnel), contenant la liste des différents caractères,
leur positions, leurs couleurs... Notre version modifée, nommée
XpLoaderPy3, fonctionne donc sous Python 3 et affiche ces images issues
de fichiers .xp dans une console TDL (plutôt que libtcod), et possède
quelques fonctionnalités supplémentaires quant à l'originale, comme la
possibilité de décaler l'affichage de l'image, ou de choisir de ne pas
afficher les caractères transparents. Nous avons décidé de faire une
page <a href="https://github.com/Edern76/XPLoaderPy3" rel="me">GitHub séparée</a> pour ce module (notez que
cela est permis par la license MIT, du moment que l'on cite l'auteur
original) afin que d'autres développeurs puissent l'utiliser. Cela a eu
pour conséquence que le développeur de <span style="font-weight: bold;">REXPaint</span> a décidé
d'inclure un lien vers notre version de ce module sur <a href="http://www.gridsagegames.com/rexpaint/resources.html">son
site internet</a> (sous la catégorie 'Libraries').<br>
Ce module est inclus dans le dossier code, et ne nécessite pas de
quelconque installation. L'installation de REXPaint n'est pas non plus
nécessaire.<br>
<br>
Si vous désirez lancer le programme à partir du code source, vous aurez
besoin des modules suivants :&nbsp;
<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -
libtcod-cffi (<strong><span style="font-weight: bold;">version
1.0</span></strong>)
: Module sur lequel est basé TDL.
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -
simpleaudio : Module utilisé pour gérer le son.
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - cffi
(*) : Module utilisé par libtcod-cffi. L'installation
peut être un peu plus compliquée sous Unix que sous Windows (il est en
effet possible qu'il faille installer un certain package avec la
commande <span style="font-style: italic;">sudo apt-get
install </span>avant d'effectuer <span style="font-style: italic;">pip install)</span>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - dill<span style="font-style: italic;"> </span>(*)
: Utilisé
pour la sauvegarde des fichiers. Il permet de rajouter la capactié de
sauvegarder les expressions lambda (que nous utilisons dans notre
projet) au module shelve qui gère d'habitude la sauvegarde. Nous avons
donc modifié le module shelve (présent dans la libraire standard
Python)
pour qu'il utilise dill, en remplacant l'importation de pickle par
l'importation de dill.<br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; - ffmpy :
Utilisé pour convertir les fichiers sons au format mp3 vers le format
wav. En effet, simpleaudio ne supporte que les fichiers wav, et les
inclure directement dans le programme génèrerait des temps d'upload
vers GitHub beaucoup trop importants. <span style="text-decoration: underline;">Nécessite d'avoir un
exécutable de ffmpeg approprié à votre système d'exploitation dans le
dossier code</span>.
(l'exécutable Windows est déjà inclus). Alternativement, vous pouvez
convertir vous même les fichiers mp3 dans le dossier assets/music et
les placer dans le dossier assets/sound, ce qui élimine la nécessité
d'avoir un exécutable de ffmpeg dans le dossier (ffmpy est toutefois
toujours requis).<br>
<br>
<ul>
</ul>
Ces modules sont tous censés fonctionner aussi bien sous Windows, Linux
que sous OSX.<br>
Les modules marqués d'un astérisque (*) sont normalement inclus avec la
distribution de Python nommée Anaconda. <br>
Si vous ne souhaitez pas installer ces modules, vous pouvez également
lancer le jeu à partir d'un fichier exécutable ne nécessitant aucun
autre module (et même aucune installation de Python) généré avec le
module cx_Freeze et le fichier setupconda.py. Cependant, nous n'avons
généré d'exécutable que pour Windows 64-bits pour le moment (pour
pouvoir générer un exécutable pour une autre plateforme, il faut
exécuter setupconda.py sur la dite plateforme, en ayant vérfié au
préalable que tous les modules requis sont bien installés, y compris
cx_Freeze). De plus, comme il faut générer manuellement ces
exécutables, ceux-ci peuvent ne pas correspondre à la dernière version
de notre programme. Vous pouvez trouver ces exécutables sur la page <a href="https://github.com/Edern76/DementiaRL/releases">Releases</a>
de notre repository GitHub.
<div class="pagebreak"> </div>
<h2 style="text-decoration: underline;"><br>
Les étapes de construction du projet : Répartition des tâches et rythme
de progression par membre du groupe.</h2>
Nous avons commencé à travailler sur notre projet bien avant la date où
nous étions censé commencer à le faire. Afin de gérer efficacement
notre travail, de garder une trace de 'qui fait quoi', d'avoir un moyen
simple et efficace de partager notre code source et de pouvoir
synchroniser nos versions du programme de façon rapide et facile, nous
avons mis en place un repository GitHub, disponible à <a href="https://github.com/Edern76/DementiaRL">cette adresse</a>.
Le fonctionnement de cet outil est relativement simple : le code source
est stocké sur un serveur. Lorsque un membre du groupe souhaite y
apporter une modification, il crée un 'commit', qui comporte la liste
des modifications, un titre et éventuellement une description, qu'il
envoie ensuite sur un serveur (on dit qu'il <span style="font-style: italic;">push</span> ce commit).
Ces modifications sont alors immédiatement disponibles pour l'autre
membre, qui n'a plus qu'à entrer <span style="font-style: italic;">git
pull</span> dans un shell ou à cliquer sur le bouton <span style="font-style: italic;">Sync</span> de
l'application <span style="font-style: italic;">GitHub
Desktop</span>. En cas de conflit, c'est à dire si deux commits
modifient la même partie d'un fichier, GitHub prévient de ce conflit en
isolant les parties en question dans le fichier posant problème et en
incluant les deux versions en conflit. Pour résoudre ce conflit, il
suffit d'effacer la version que l'on ne souhaite pas conserver (ou de
la modifier pour qu'elle incluse l'autre version, ce qui n'est pas
toujours possible) puis de créer un nouveau commit.<br>
<br>
Il est également possible de maintenir plusieurs versions d'un même
programme simultanément grâce à cet outil. Ces versions sont appelées
des branches. La branche <span style="font-style: italic;">master</span>
est la branche principale de notre programme, elle correspond à une
version relativement stable. Afin d'éviter d'introduire des bugs dans
cette branche, nos commits sont <span style="font-style: italic;">pushés</span>
sur une branche secondaire, la branche <span style="font-style: italic;">secondary</span>. Lorsque
nous avons effectué plusieurs commits successifs sur cette branche
secondaire, et que l'ensemble n'est pas trop instable, on rappatrie les
changements vers la branche <span style="font-style: italic;">master</span>,
en effectuant un <span style="font-style: italic;">pull
request</span>. Vous pourrez constater qu'il existe beaucoup plus
que deux branches, nous avons en effet crée plusieurs branches
correspondant à des sauvegardes de la branche <span style="font-style: italic;">master</span> a des dates
donnée (à la fois pour prévenir des éventuels problèmes et pour pouvoir
nous rendre compte plus facilement de l'évolution du projet). De plus,
lorsque nous avons implémenté des fonctionnalités risquant
particulièrement de provoquer des erreurs, nous avons crée de nouvelles
branches à partir de <span style="font-style: italic;">secondary</span>,
et lorsque nous nous étions assuré que les dites erreurs avaient
disparu, nous avons effectué un <span style="font-style: italic;">pull
request</span> de cette nouvelle branche vers <span style="font-style: italic;">secondary</span> (ou,
lorsque trop d'erreurs survenaient, nous avons 'abandonné' ces
branches, et repris le développement sur secondary à partir de là où
l'on en était avant cette branche).<br>
<br>
La répartition du travail jusqu'à maintenant est disponible dans
l'historique des commits. Celui-ci affiche tous les commits ayant été
effectués sur une branche, ainsi que leur auteur. Le pseudo de Erwan
est <span style="font-style: italic;">Malan-Tai</span>
(avatar rose) et celui de Gawein est <span style="font-style: italic;">Edern76</span> (avatar
vert). Le pseudo<span style="font-style: italic;"> lasTH76</span>
(avatar rouge) correspond à un autre camarade du groupe d'ISN qui
voulait initialement se joindre à nous, mais a ensuite changé d'avis.
Il n'existe cependant plus aucune trace de ses modifications dans la
version finale (il avait commencé à séparer le code du fichier main.py
en modules, ce qui s'est avéré poser un très grand nombre de problèmes
par la suite, nous avons donc préféré le rapattrier dans le fichier
main.py et ne mettre dans des modules séparés que le code ne dépendant
d'aucun élément de main.py, comme par exemple le générateur de nom, les
constantes...). En cliquant sur un commit, vous pourrez voir ses
détails : à savoir quelles modifications ont été apportées à quels
fichiers. L'historique des commits de la branche <span style="font-style: italic;">secondary</span> (celle
mise à jour le plus souvent, l'historique de la branche <span style="font-style: italic;">master</span> est
cependant à peu près simillaire si ce n'est qu'il inclus en plus les <span style="font-style: italic;">pull requests</span>) est
donc disponible <a href="https://github.com/Edern76/DementiaRL/commits/secondary">ici</a>.
Les noms des commits sont en anglais car comme pour XpLoaderPy3, nous
souhaitons que le reste de la communauté de développeurs de roguelikes
puisse bénéficier de notre travail et comprendre comment s'est effectué
le processus de développement de notre projet.<br>
<br>
Il
est de plus important de noter que nous avons procédé de la même
manière pour rédiger ce dossier, grâce à l'éditeur HTML gratuit
KompoZer, car GitHub est non seulement capable de reconnaître des
modifications d'un fichier python mais aussi de fichiers HTML, et
toutes sortes d'autres fichiers reposant sur un code source.<br>
<br>
<div class="pagebreak"></div>
<h2 style="text-decoration: underline;"><br>
Le développement algorithmique et programmatique du projet : Une partie
liée au travail du membre auteur de ce livret.</h2>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 1&nbsp; :
Génération de cavernes (automate cellulaire)</span><br>
&nbsp;</h3>Cette
partie est consacrée à la présentation du code de mon binôme quant à
son automate cellulaire et ne sera donc pas traitée dans ce dossier.<br><h3 class="">&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 2&nbsp; :
Gestion des buffs et debuffs</span><br>
&nbsp;</h3>
<p><span style="font-style: italic;"></span><span style="text-decoration: underline;"><span style="font-style: italic;">N.B.:</span></span><span style="font-style: italic;"> dans les extraits de code
ci-dessous, on constatera souvent la mention </span>.Fighter<span style="font-style: italic;">. Cela désigne le composant </span>Fighter<span style="font-style: italic;"> de la classe </span>GameObject<span style="font-style: italic;">, à savoir une classe dans une
classe, permettant une division et une répartition plus claire des
différents attributs et méthodes. Ainsi, la classe </span>GameObject<span style="font-style: italic;"> désigne tout objet du jeu, que
ce soit une épée, un monstre ou un escalier, tandis que le composant </span>Fighter<span style="font-style: italic;"> n'est possédé que par les
créatures vivantes, donc les monstres, les Personnages Non Jouables et
le joueur.</span></p>
<p>Un <span style="font-style: italic;">buff</span>
est un terme vidéoludique désignant une condition physique ou mentale
temporaire positive, comme par exemple un gain de force ou la capacité
de voler, mais ce sur une période de temps plus ou moins longue. Le <span style="font-style: italic;">debuff</span> est son
équivalent négatif, et peut par exemple être un poison ou une cécité
temporaire. Ces deux catégories seront dans la suite de cette partie
citées sous le nom de buff, afin de simplifier le propos.</p>
<p><img class="displayed" style="width: 812px; height: 88px;" alt="" src="../../../Pictures/poison_debuff.jpg"></p>
<p><img class="displayed" style="width: 1208px; height: 88px;" alt="" src="../../../Pictures/werewolf.jpg"></p>
<p><img class="displayed" style="width: 1203px; height: 85px;" alt="" src="../../../Pictures/human_werewolf.jpg"></p>
<div style="text-align: center;"><span style="font-style: italic;">Trois exemples de buffs:<br>
1) Du poison, qui inflige des dégâts au joueur pendant un certain temps<br>
2) La transformation d'un joueur en loup-garou, puis en 3) le retour à
sa forme humaine, entraînant une modification visible à gauche de ses
statistiques.</span></div>
<p>Afin que le jeu puisse garder en mémoire tous les buffs
appliqués à un instant <span style="font-style: italic;">t</span>,
il faut créer une classe Buff dont chaque instance sera unique et liée
à la créature qui la subit.</p>
<div class="code"><span style="font-weight: bold;">class
Buff:</span><br>
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">def
__init__</span>(self, name, color, owner =
None, cooldown = 20, showCooldown = True, showBuff = True,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
applyFunction = None, continuousFunction = None, removeFunction = None):<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-style: italic;">#une fonction servant à initialiser la classe Buff, c'est-à-dire en créer une nouvelle instance</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.name = name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.color = color<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.baseCooldown = cooldown<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.curCooldown = cooldown<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.applyFunction = applyFunction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.continuousFunction = continuousFunction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.removeFunction = removeFunction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.owner = owner<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.showCooldown = showCooldown<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.showBuff = showBuff<br>
</div>
<p>Cette classe possède dix attributs différents. L'attribut <span style="font-style: italic;">name</span> est simplement
le nom du buff, comme 'poisonned' par exemple. Les attributs <span style="font-style: italic;">color</span>, <span style="font-style: italic;">showBuff</span>, <span style="font-style: italic;">showCooldown</span> sont
purement esthétiques, <span style="font-style: italic;">color</span>
déterminant la couleur dans laquelle apparaîtront les messages relatifs
au buff, <span style="font-style: italic;">showBuff</span>
déterminant si le buff et ses messages doivent être affichés, et <span style="font-style: italic;">showCooldown</span>
déterminant si le&nbsp;<span style="font-style: italic;">cooldown</span>,
c'est-à-dire la durée restante, du buff doit être affiché. Les
attributs&nbsp;<span style="font-style: italic;">baseCooldown&nbsp;</span>et&nbsp;<span style="font-style: italic;">curCooldown</span> servent
justement à surveiller le cooldown du buff, <span style="font-style: italic;">baseCooldown</span>
servant à garder une trace du cooldown d'origine, et&nbsp;<span style="font-style: italic;">curCooldown</span>
diminuant à chaque tour, comme nous le verrons, afin de savoir quand le
buff doit s'arrêter. L'attribut&nbsp;<span style="font-style: italic;">owner&nbsp;</span>sert
à savoir à quelle créature est appliqué le buff. Enfin, les trois
derniers attributs&nbsp;<span style="font-style: italic;">applyFunction</span>,&nbsp;<span style="font-style: italic;">continuousFunction&nbsp;</span>et&nbsp;<span style="font-style: italic;">removeFunction</span> sont
en réalité des méthodes variant d'un buff à l'autre, c'est pourquoi ils
ne sont pas définis dans la classe directement mais plutôt référencés
en tant qu'attributs spécifiques. Ils servent à savoir comment se
comportera le buff à différents moments, à savoir resectivement lorsque
le buff est appliqué pour la première fois, lorsqu'un tour passe, et
lorsque le buff disparaît. Ces trois méthodes spécifiques sont appelées
dans des méthodes communes à tous les buffs.</p>
<div class="code">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">def
applyBuff</span>(self, target):<br><span style="font-style: italic;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #on exécute&nbsp;cette fonction lorsque le buff vient d'être subi</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.owner = target<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if not self.name in convertBuffsToNames(target.Fighter): <span style="font-style: italic;">#si </span>target<span style="font-style: italic;"> ne subit pas déjà ce buff</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.curCooldown = self.baseCooldown <span style="font-style: italic;">#on initialise le cooldown</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.showBuff: <span style="font-style: italic;">#on prévient le joueur si showBuff est True</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
message(self.owner.name.capitalize() + ' is now ' + self.name + '!',
self.color)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.applyFunction is not None: <span style="font-style: italic;">#on appelle la méthode applyFunction si elle existe</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.applyFunction(self.owner.Fighter)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.owner.Fighter.buffList.append(self) <span style="font-style: italic;">#on ajoute le buff à la liste des buffs de la cible</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bIndex = convertBuffsToNames(self.owner.Fighter).index(self.name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
target.Fighter.buffList[bIndex].curCooldown += self.baseCooldown<span style="font-style: italic;"> #sinon (si </span>target<span style="font-style: italic;"> subit déjà ce buff, on lui<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;rajoute du temps</span>
</div>
<p>La méthode&nbsp;<span style="font-style: italic;">applyBuff</span>
permet d'appliquer le buff, par exemple lorsqu'un serpent mord le
joueur et l'empoisonne.&nbsp;</p>
<p>Elle attribue tout d'abord au buff son nouveau propriétaire, à
savoir la cible référencée par l'argument <span style="font-style: italic;">target</span> de la
méthode. Puis elle vérifie que le buff n'est pas déjà appliqué à la
cible, afin que celle-ci ne subisse pas deux fois l'application d'un
même buff.</p>
<p>Si le buff n'est pas déjà appliqué, la méthode va alors
initialiser le cooldown du buff et envoyer si nécessaire un message
avertissant le joueur qu'une créature ou lui-même subit l'effet du
buff. Elle va ensuite&nbsp;appeler, si elle existe, la méthode <span style="font-style: italic;">applyFunction</span> du
buff, et va enfin ajouter à la liste de buffs de la cible le nouveau
buff. Sinon, on rajoute au cooldown du buff déjà appliqué le cooldown du nouveau buff identique.</p>
<div class="code">
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">def
passTurn</span>(self):<br><span style="font-style: italic;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #cette fonction est exécutée chaque tour</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.curCooldown -= 1 <span style="font-style: italic;">#on réduit d'un tour le cooldown restant</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.curCooldown &lt;= 0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.removeBuff() <span style="font-style: italic;">#si le cooldown du buff atteint 0, on le supprime</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.continuousFunction is not None: <span style="font-style: italic;">#sinon, on exécute la fonction devant s'appliquer chaque tour</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.continuousFunction(self.owner.Fighter)</div>
<p>Puis la méthode&nbsp;<span style="font-style: italic;">passTurn</span>
permet de réduire d'un tour le cooldown du buff. Si le cooldown a
atteint 0, elle appelle alors la méthode&nbsp;<span style="font-style: italic;">removeBuff</span> décrite
ci-dessous afin de faire disparaître le buff. Sinon, elle appelle si
elle existe la méthode&nbsp;<span style="font-style: italic;">continuousFunction</span>
du buff, afin par exemple d'infliger des dégâts de feu à la cible.</p>
<div class="code">
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">def
removeBuff</span>(self):<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-style: italic;">#comme vu plus haut, on exécute cette fonction lorsque le cooldown a atteint 0</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.removeFunction is not None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.removeFunction(self.owner.Fighter) <span style="font-style: italic;">#on exécute la potentielle fonction de fin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.owner.Fighter.buffList.remove(self) <span style="font-style: italic;">#on supprime le buff de la liste de la créature le subissant</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.owner.Fighter.buffList is None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.owner.Fighter.buffList = [] <span style="font-style: italic;">#on réinitialise si besoin la liste de la créature susdite</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.showBuff:&nbsp;<span style="font-style: italic;">#on prévient si besoin le joueur</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
message(self.owner.name.capitalize() + ' is no longer ' + self.name +
'.', self.color)<span style="font-style: italic;"></span></div>
<p>Enfin, la méthode <span style="font-style: italic;">removeBuff</span>
sert à faire disparaître le buff. Pour ce faire, elle va tout d'abord
appeler si elle existe la méthode&nbsp;<span style="font-style: italic;">removeFunction</span> du
buff. Puis elle va supprimer de la liste de buffs du propriétaire du
buff, le buff en question. Enfin, elle envoie si nécessaire un message
afin de notifier le joueur de la disparition du buff.</p>
<p>Cependant, si les buffs sont bel et bien stockés pour chaque
créature en subissant les effets, ils ne sont pour l'instant appelés en
jeu qu'au moment de leur application. Il faut donc les appeler dans la
boucle principale du jeu, comme suit. (<span style="text-decoration: underline;"><span style="font-style: italic;">N.B.:</span></span><span style="font-style: italic;"> certains fragments du code ont
ici été effacés afin de ne représenter que la partie qui nous intéresse</span>)
</p>
<div class="code"><span style="font-weight: bold;">
def playGame</span>():<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; while not tdl.event.isWindowClosed(): <span style="font-style: italic;">#tant que la fenêtre n'est pas fermée</span><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
gameState == 'playing' and playerAction != 'didnt-take-turn':<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for object in objects: <span style="font-style: italic;">#pour chaque instance de la classe GameObject dans la liste objects</span><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if object.Fighter and object.Fighter is not None: <span style="font-style: italic;">#si l'objet est vivant<br></span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for buff in object.Fighter.buffList:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
buff.passTurn()&nbsp;<span style="font-style: italic;">#on passe n tour pour chacun de ses buffs</span></div>
<p>Dans la fonction principale <span style="font-style: italic;">playGame</span>, on joue
jusqu'à ce que la fenêtre soit fermée, ce qui est représenté par la
boucle <span style="font-style: italic;">while</span>.
Dans celle-ci, on vérifie que le jeu doit bien passer un tour (ce qui
n'est par exemple pas le cas si le jouer doit cibler une case, auquel
cas le <span style="font-style: italic;">gameState </span>sera
égal à <span style="font-style: italic;">targeting</span>
au lieu de <span style="font-style: italic;">playing</span>)
et si le joueur a bien fait une action. Si c'est le cas, on itère à
travers la liste de tous les objets présents en jeu. Si chaque
itération, sous le nom <span style="font-style: italic;">object</span>,
possède un composant <span style="font-style: italic;">Fighter</span>,
et, si c'est le cas, on itère alors dans la liste des buffs appliqués à
celui-ci, en appelant à chaque fois la méthode <span style="font-style: italic;">passTurn</span> du buff
itéré. Cela va donc permettre d'appliquer les éventuelles fonctions
continues <span style="font-style: italic;">continuousFunction
</span>et de réduire d'un tour le cooldown de chaque buff.</p>
<p><span style="text-decoration: underline;"><span style="font-weight: bold;">Un exemple du fonctionnement des
buffs: la lycanthropie</span></span></p>
<p><img class="displayed" style="width: 1208px; height: 88px;" alt="" src="../../../Pictures/werewolf.jpg"></p>
<p><img class="displayed" style="width: 1203px; height: 85px;" alt="" src="../../../Pictures/human_werewolf.jpg"></p>
<p></p>
<p><span style="text-decoration: underline;"><span style="font-weight: bold;"></span></span>Afin
d'illustrer le code présenté ci-dessus, je vais maintenant présenter un
extrait de code permettant de gérer la lycanthropie du personnage que
l'on peu constater ci-dessus.</p>
<div class="code">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
object.Player and object.Player.race == 'Werewolf':<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="font-weight: bold;">def shapeshift</span>(fighter,
fromWolf = False, fromHuman = True): <span style="font-style: italic;">#on définit une fonction interne échangeant<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;l'état théorique du joueur</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if fromWolf:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
player.Player.shapeshift = 'human'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object.Player.shapeshifted = True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if fromHuman:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
player.Player.shapeshift = 'wolf'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object.Player.shapeshifted = True<br>
<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-style: italic;">#On crée deux instances de la classe buff</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
human = <span style="font-weight: bold;">Buff</span>('human',
colors.lightest_yellow, cooldown = player.Player.human, showBuff =
False,<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; applyFunction
= <span style="font-weight: bold;">lambda</span>
fighter: setFighterStatsBack(fighter),
removeFunction = <span style="font-weight: bold;">lambda</span>
fighter:<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;shapeshift(fighter)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wolf = <span style="font-weight: bold;">Buff</span>('in
wolf form', colors.amber, cooldown = player.Player.wolf, applyFunction
= <span style="font-weight: bold;">lambda</span>
fighter:<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;modifyFighterStats(fighter, str = 5, dex
= 3, vit = 4, will = -5), removeFunction = <span style="font-weight: bold;">lambda</span> fighter:<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;shapeshift(fighter, fromHuman=False,
fromWolf=True))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if object.Player.shapeshifted: <span style="font-style: italic;">#si le joueur doit changer de forme ce tour-ci, on applique le buff<br>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;correspondant </span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if object.Player.shapeshift == 'wolf':<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
message('You feel your wild instincts overwhelming you! You have turned
into your wolf form!',<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;colors.amber) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wolf.applyBuff(player)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object.Player.shapeshifted = False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if object.Player.shapeshift == 'human':<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
human.applyBuff(player)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object.Player.shapeshifted = False</div>
<p>Ceci est un extrait de la fonction <span style="font-style: italic;">playGame</span>. On y
définit la fonction <span style="font-style: italic;">shepashift</span>,
permettant de jongler entre les formes humaine et loup-garou du joueur.
Puis on y définit les buffs <span style="font-style: italic;">human
</span>et <span style="font-style: italic;">wolf</span>.
Attardons-nous sur leurs méthodes spécifiques.</p>
<div class="code">
human = <span style="font-weight: bold;">Buff</span>(...applyFunction
= <span style="font-weight: bold;">lambda</span>
fighter: setFighterStatsBack(fighter),
removeFunction = <span style="font-weight: bold;">lambda</span>
fighter:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; shapeshift(fighter))</div>
<p>On voit ici l'apparition du mot-clé <span style="font-weight: bold;">lambda: </span>. Il est
vital
ici, car, sans lui, on aurait eu&nbsp;<span style="font-style: italic;">applyFunction =
setFighterStatsBack()</span>, ce qui aurait poussé le programme à
éxecuter la fonction&nbsp;<span style="font-style: italic;">setFighterStatsBack</span>
à chaque fois que le buff&nbsp;<span style="font-style: italic;">human</span>
aurait été appelé, comme si cette fonction retournait une valeur grâce
à un&nbsp;<span style="font-style: italic;">return</span>,
ce qui n'est pas le cas ici. On utilise alors&nbsp;<span style="font-weight: bold;">lambda:</span> afin de
signaler au programme qu'on ne souhaite pas éxecuter une fonction mais
plutôt déterminer une méthode. Le fait qu'on aie&nbsp;<span style="font-style: italic;">fighter&nbsp;</span>avant
les deux points signifie que lorsque l'on appellera la méthode <span style="font-style: italic;">applyFunction</span>, on
écrira&nbsp;<span style="font-style: italic;">buff.applyFunction(fighter</span>&nbsp;<span style="font-style: italic;">= something)</span>, ce
qui placera l'argument&nbsp;<span style="font-style: italic;">fighter</span>
là où il est référencé dans la méthode&nbsp;<span style="font-style: italic;">shapeshift</span> par
exemple.</p>
<div class="code">
wolf = <span style="font-weight: bold;">Buff</span>(...applyFunction
= <span style="font-weight: bold;">lambda</span>
fighter: modifyFighterStats(fighter, str = 5, dex
= 3, vit = 4, will = -5),<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;removeFunction = <span style="font-weight: bold;">lambda</span> fighter:
shapeshift(fighter, fromHuman=False,
fromWolf=True))</div>
<p>De même pour le buff&nbsp;<span style="font-style: italic;">wolf</span>,&nbsp;<span style="font-weight: bold;">lambda</span>
est vital car il permet de déterminer une méthode avec des arguments
différents de ceux par défaut. En effet, on aurait pu écrire&nbsp;<span style="font-style: italic;">applyFunction =
modifyFighterStats</span>, ce qui aurait permis, de même
qu'avec&nbsp;<span style="font-weight: bold;">lambda</span>,
de déterminer une méthode sans éxectuter la fonction référencée.
Cependant, on n'aurait pas pu en modifier les arguments comme on le
fait ci-dessus. C'est ce dernier détail qui fait la grande force
de&nbsp;<span style="font-weight: bold;">lambda</span>.</p>
<p>Pour en revenir à l'extrait de code nous intéressant, le buff <span style="font-style: italic;">human </span>est
dès le début de la partie appliqué au joueur. Cela signifie que, dès le
début de la partie, le cooldown de la forme humaine du joueur diminue,
jusqu'au moment où elle atteint 0. Le méthode <span style="font-style: italic;">removeFunction </span>est
alors appelée, entraînant l'exécution de la fonction <span style="font-style: italic;">shapeshift</span>. Le
joueur a alors comme attribut <span style="font-style: italic;">shapeshifted
= True</span> et <span style="font-style: italic;">shapeshift
= 'wolf'</span>. Le test <span style="font-style: italic;">if
object.Player.shapeshifted</span> est alors réussi, et on
applique alors le buff <span style="font-style: italic;">wolf</span>
au joueur, et ainsi de suite.<span style="font-weight: bold;"></span>
</p><br><h2 style="text-decoration: underline;">Les implications
du projet : Une partie liée aux problématiques
sociétales liées au projet.</h2>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 1&nbsp; :
La communauté</span><br>
&nbsp;</h3>
<p>Nous espérons créer, avec ce jeu, malgré son intérêt assez
faible
par rapport aux géants du genre comme Cogmind, une communauté de
joueurs du monde entier qui pourraient se regrouper sur internet par le
biais de forums, ou de groupes de discussion de type IRC afin de
discuter des
différentes stratégies possibles, des secrets qu'ils auront trouvés ou
encore pour demander de l'aide, ce qui permettrait de rapprocher ces
joueurs entre eux malgré les distances physiques qui les séparent.
C'est pourquoi nous avons décidé
d'écrire le jeu en anglais, afin de l'ouvrir au plus grand nombre. De
même, nous avons écrit le code source en anglais afin de faciliter la
tâche de personnes souhaitant en créer et en partager des variantes
et/ou des modifications, dans le but de personaliser leur expérience de
<span style="font-style: italic;">Dementia RL</span>,
ce qui le coeur de l'esprit OpenSource.</p>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 2&nbsp; :
Le risque d'addiction</span><br>
&nbsp;</h3>
<p>Comme tout objet culturel voué à susciter le divertissement,
notre
jeu est susceptible de provoquer une addiction chez les utilisateurs.
Cela peut avoir un impact négatif sur la société, car si une personne
joue à <span style="font-style: italic;">Dementia RL</span>
la nuit
au lieu de dormir, elle sera bien moins productive le lendemain au
travail ou à l'école. De plus, notre jeu utilisant de façon assez
importante le processeur (ou CPU) afin de tenter de compenser la
lenteur inhérente au langage Python (voir partie sur les problèmes
rencontrés), une utilisation prolongée de <span style="font-style: italic;">Dementia RL</span>
peut provoquer une hausse de température du CPU, ce qui va à long terme
l'endommager et forcer l'utilisateur à en racheter un nouveau. On peut
même imaginer que, désireuses d'obtenir de meilleures performances sur
<span style="font-style: italic;">Dementia RL</span>,
certains
personnes augmentent la fréquence de leur processeur au délà de ce qui
est prévu par le manufactureur (on appelle ce procédé overclocking),
accélérant encore plus cette dégradation du processeur. Afin de pallier
à ce problème, nous aurions pu ajouter dans un coin de la fenêtre un
compteur mesurant le temps de la session actuelle, et dont la couleur
virerait vers le rouge au fur et à mesure que celle-ci s'allonge, mais
nous ne l'avons pas fait car nous en avons eu l'idée à la toute fin de
l'année scolaire, et par conséquent nous avons manqué de temps afin de
l'implémenter à temps pour l'oral d'ISN, malgré la simplicité d'une
telle chose. Il s'agit donc d'une fonctionnalité sur laquelle nous
travaillerons après ce dernier. </p>
<div><br>
</div>
<h2><br>
<span style="text-decoration: underline;">Les problèmes
rencontrés au cours du développement du projet : L'ensemble des
problèmes et solutions recontrés et trouvés par le groupe.</span></h2>
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 1&nbsp; :
Limitations techniques</span>&nbsp;</h3>
Nous
avons choisi de réaliser notre projet en Python 3, car il s'agit du
langage que nous avons étudié en ISN au cours de l'année. De plus, la
simplicité de ce langage permet de concrétiser rapidement nos idées
sans avoir à se préoccuper de l'allocation de la mémoire (contrairement
à certains langages de plus 'bas niveau' que Python, c'est à dire plus
proches du fonctionnement de la machine, comme par exemple le C++) ou à
se heurter à une syntaxe trop rigide. Cependant, ce langage comporte
aussi des inconvénients : le premier étant qu'il est beaucoup plus lent
que la plupart des autres langages. Cela commence à poser problème
lorsque plusieurs ennemis doivent calculer un chemin vers le joueur ou
lorsque l'on doit sauvegarder ou charger un grand nombre de données
(lors du changement de niveau par exemple), ce qui provoque une
interruption temporaire du jeu, le temps que les opérations en cours
s'effectuent. De plus, une des seules bibliothèques en Python 3
permettant de créer un roguelike est TDL (portage de la librairie
libtcod). Or, celle-ci ne nous permet pas de changer facilement la
taille de la police, ce qui fait que nous sommes forcés d'utiliser des
petits caractères, qui peuvent être difficiles à lire. Nous allons
tenter de créer notre propre police dans des dimensions supérieures à
celle utilisée par défaut par TDL, mais nous ne sommes pas du tout
certains que cela fonctionnera et/ou que cela aboutisse effectivement à
un agrandissment des caractères présents sur l'écran.
<h3>&nbsp;&nbsp;&nbsp; <span style="text-decoration: underline;">Partie 2&nbsp; :
&nbsp;L'organisation du code (modulation)</span><br>
</h3>
<p>Ce projet étant pour tous deux une première réelle expérience
de
développement d'un jeu vidéo, ainsi que nos premiers pas en python et
avec la bibliothèque TDL, nous nous sommes aidés, lors des premières
étapes du projet, d'un tutoriel trouvé sur Internet. Cependant, nous
avons vite dépassé le stade auquel ce tutoriel était arrêté, et nous
avons donc décidé, plutôt que de recommencer le code à 0 en nous
servant des compétences acquises grâce au tutoriel, de continuer au
point ou nous en étions. Mais nous avons vite regretté cette décision.
En effet, le code devint vite illisible et anarchique, et nous nous
serions certainement perdus sans la fonction de recherche (ctrl+F) de
notre environnement de développement. Nous avons donc tenté d'éclater
notre projet en différents modules, mais avons vite fait marche arrière
lorsque nous nous sommes rendus compteque des références réciproques
étaient nécessaires à chaque tentative. Par exemple, la création du
personnage, qui avait été déplacée vers son propre
module, faisait référence à des variables globales situées dans le
fichier<span style="font-style: italic;"> main.py</span>.
Mais ce même fichier <span style="font-style: italic;">main.py
</span>fasait référence à des
fonctions situées dans le module de la création de personnage, créant
ainsi des boucles d'importations dangereuses pour la stabilité du
programme. Nous avons donc abandonné l'idée de moduler le code déjà
existant et avons donc commencé à créer des modules seulement à la
suite de ce problème.</p>
<h2 style="text-align: center;"><span style="color: rgb(0, 128, 0);">Évaluation au fil du projet.</span></h2>
<table style="height: 100px; width: 500px;" align="center" border="3" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td colspan="2" rowspan="1">Tâches définies
et réparties</td>
<td colspan="2" rowspan="1">Projet ,
description, éléments de programmation ou d'algorithme</td>
<td colspan="2" rowspan="1">Compte rendu
final , contenus, état de rédaction</td>
<td style="text-align: center;">Note</td>
<td>Semaine</td>
</tr>
<tr>
<td><span style="color: rgb(0, 100, 0);">+</span></td>
<td><span style="color: rgb(0, 100, 0);">répartition
voir Github ? </span></td>
<td>&nbsp;description : <span style="color: rgb(0, 100, 0);">Oui</span></td>
<td>Programmation : <span style="color: rgb(0, 0, 205);">RogueLike</span>
?</td>
<td>Amorcé</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">07 03</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">14 03</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">21 03</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">28 03</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">04 04</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">25 04</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">2 05</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">9 05</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">16 05</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">23 05</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td style="text-align: center;">/5</td>
<td style="text-align: center;">30 05</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
</body></html>